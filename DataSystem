#define _CRT_SECURE_NO_WARNINGS 1

#pragma warning(disable:6031)

#pragma warning(disable:6011)

#include <stdio.h>

#include <stdlib.h>

#include <string.h>

#include <malloc.h>

#include <assert.h>



#define STR_LEN 24

#define CHILD_LEN 64

#define BUFFER_SIZE 1024



typedef struct _tMember {

	char name[STR_LEN];

	char wife[STR_LEN];

}Member, * pMember;



typedef struct _tTreeNode {

	Member member;

	struct _tTreeNode* parent;

	struct _tTreeNode* children[CHILD_LEN];

	int count;

	int level;

}TreeNode, * pTreeNode;



pTreeNode createTreeNode(pTreeNode parent, pMember member) {

	pTreeNode node = (pTreeNode)calloc(1, sizeof(TreeNode));

	if (node) {

		node->member = *member;

		if (parent) {

			node->parent = parent;

			node->level = parent->level + 1;

			parent->children[parent->count++] = node;

		}

	}

	return node;

}



void removeTreeNode(pTreeNode cursor) {

	if (cursor) {

		if (cursor->parent) {

			pTreeNode parent = cursor->parent;

			int position = -1;

			for (int index = 0; index < parent->count; ++index) {

				if (parent->children[index] == cursor) {

					position = index;

					break;

				}

			}

			if (position != -1) {

				for (int index = position + 1; index < parent->count; ++index) {

					parent->children[index - 1] = parent->children[index];

				}

				--parent->count;

			}

		}

	}

}



int countMemberLevel(const char content[]) {

	int level = 0;

	const char* cursor = content;

	while (*cursor == ' ') {

		++level;

		++cursor;

	}

	return level;

}



void inputSex(char sex[]) {

	do {

		int option;

		printf("\n");

		printf("----------\n");

		printf(" 1 男\n");

		printf(" 2 女\n");

		printf("----------\n");

		printf(" 请选择：");

		scanf("%d", &option);

		switch (option) {

		case 1:

			strcpy(sex, "男");

			return;

		case 2:

			strcpy(sex, "女");

			return;

		}

	} while (1);

}



int checkDate(const char date[]) {

	int yyyy, mm, dd;

	if (strlen(date) != 10) return 0;

	if (sscanf(date, "%4d-%2d-%2d", &yyyy, &mm, &dd) != 3) return 0;

	if (yyyy < 1999)return 0;

	if (yyyy >= 3000) return 0;

	if (mm < 1) return 0;

	if (mm > 12) return 0;

	if (dd < 1) return 0;

	if (dd > 31) return 0;

	return 1;

}



void inputDate(char date[]) {

	do {

		scanf("%s", date);

		if (checkDate(date)) break;

		printf("格式错误，请重新输入！（yyyy-mm-dd）\n");

	} while (1);

}



void editFamilyMember(pMember member) {

	printf("╔-----------------------------------------╗\n");

	printf(" * 编辑家谱成员信息 *\n");

	if (strlen(member->name)) {

		printf(" 姓名：%s\n", member->name);

	}

	else {

		printf(" 姓名：");

		scanf("%s", member->name);

	}
	printf(" 1修改男 0修改女：\n");
	int k;
	scanf("%d", &k);
	if (k)
	{
		printf(" 丈夫：");
		scanf("%s", member->name);
	}
	else
	{
		printf(" 妻子：");
		scanf("%s", member->wife);
	}

	printf("╚-----------------------------------------╝\n");

}



void showFamilyMemberTitle() {

	printf(" %-10s", "姓名");

	printf(" %-10s", "妻子");

	printf("\n");

}



void showFamilyMember(pMember member, int newline) {

	printf(" %-10s", member->name);

	printf(" %-10s", member->wife);

	if (newline) {

		printf("\n");

	}

}



void recursiveFamilyTreeNodeShow(pTreeNode cursor, int brother_line[], int flag, int all) {

	if (cursor) {

		char generation[STR_LEN] = { 0 };

		if (all) {

			showFamilyMember(&cursor->member, 0);

		}

		sprintf(generation, "【%d世】", cursor->level + 1);

		printf("%10s", generation);

		if (cursor->level > 0) {

			for (int index = 0; index < cursor->level - 1; ++index) {

				if (brother_line[index]) {

					printf(" │");

				}

				else {

					printf(" ");

				}

			}

			if (flag) {

				printf(" ├─>");

			}

			else {

				printf(" └─>");

			}

		}

		printf(" %s %s\n", cursor->member.name, cursor->member.wife);

		for (int index = 0; index < cursor->count; ++index) {

			int flag = (index < cursor->count - 1);

			if (flag) {

				brother_line[cursor->level] = 1;

			}

			else {

				brother_line[cursor->level] = 0;

			}

			pTreeNode child = cursor->children[index];

			recursiveFamilyTreeNodeShow(child, brother_line, flag, all);

		}

		brother_line[cursor->level] = 0;

	}

}



void recursiveFamilyTreeNodeSave(pTreeNode cursor, FILE* output) {

	if (cursor) {

		if (cursor->level > 0) {

			char format[STR_LEN] = { 0 };

			sprintf(format, "%%%ds", cursor->level);

			fprintf(output, format, " ");

		}

		fprintf(output, "%s ", cursor->member.name);

		fprintf(output, "%s ", cursor->member.wife);

		fprintf(output, "\n");

		for (int index = 0; index < cursor->count; ++index) {

			pTreeNode child = cursor->children[index];

			recursiveFamilyTreeNodeSave(child, output);

		}

	}

}



pTreeNode recursiveFamilyTreeNodeFind(pTreeNode cursor, const char name[]) {

	if (cursor) {

		if (strcmp(cursor->member.name, name) == 0 || strcmp(cursor->member.wife, name) == 0) {

			return cursor;

		}

		for (int index = 0; index < cursor->count; ++index) {

			pTreeNode child = cursor->children[index];

			pTreeNode result = recursiveFamilyTreeNodeFind(child, name);

			if (result) {

				return result;

			}

		}

	}

	return NULL;

}



int recursiveFamilyTreeNodeCount(pTreeNode cursor) {

	int count = 0;

	if (cursor) {

		count = 2;

		for (int index = 0; index < cursor->count; ++index) {


			pTreeNode child = cursor->children[index];

			count += recursiveFamilyTreeNodeCount(child);

		}

	}

	return count;

}



void recursiveFamilyTreeNodeClear(pTreeNode cursor) {

	if (cursor) {

		for (int index = 0; index < cursor->count; ++index) {

			pTreeNode child = cursor->children[index];

			recursiveFamilyTreeNodeClear(child);

		}

		free(cursor);

	}

}



pTreeNode loadFamilyTree() {

	pTreeNode root = NULL;

	FILE* input = fopen("familytree.txt", "r");

	if (input) {

		pTreeNode cursor = NULL;

		char buffer[BUFFER_SIZE] = { 0 };

		while (fgets(buffer, sizeof(buffer), input)) {

			Member member = { 0 };

			if (sscanf(buffer, "%s %s", member.name, member.wife) == 2) {

				int level = countMemberLevel(buffer);

				if (level == 0) {

					assert(root == NULL);

					root = createTreeNode(NULL, &member);

					cursor = root;

				}

				else {

					int step = level - cursor->level;

					assert(step <= 1);

					if (step != 1) {

						int count = 0 - step + 1;

						while (count) {

							cursor = cursor->parent;

							--count;

						}

					}

					cursor = createTreeNode(cursor, &member);

				}

			}

		}

		fclose(input);

	}

	return root;

}



void saveFamilyTree(pTreeNode root) {

	FILE* output = fopen("familytree.txt", "w");

	if (output) {

		recursiveFamilyTreeNodeSave(root, output);

		fclose(output);

	}

}



void showFamilyTree(pTreeNode root, int all) {

	printf("╔-----------------------------------------╗\n");

	printf(" * 显示家谱信息 *\n");

	int* brother_line = (int*)calloc(1024, sizeof(int));

	if (all) {

		showFamilyMemberTitle();

	}

	recursiveFamilyTreeNodeShow(root, brother_line, 0, all);

	free(brother_line);

	printf("╚-----------------------------------------╝\n");

}



void addFamilyTree(pTreeNode* root) {

	char name[STR_LEN] = { 0 };

	printf("╔-----------------------------------------╗\n");

	printf(" * 添加家谱成员 *\n");

	printf(" 输入新成员姓名：");

	scanf("%s", name);

	if (*root) {

		if (!recursiveFamilyTreeNodeFind(*root, name)) {

			pTreeNode target = NULL;

			char parentname[STR_LEN] = { 0 };

			printf(" 输入新成员的父亲或者母亲名字（指定关系）：");

			scanf("%s", parentname);

			target = recursiveFamilyTreeNodeFind(*root, parentname);

			if (target) {

				Member member = { 0 };

				strcpy(member.name, name);

				editFamilyMember(&member);

				createTreeNode(target, &member);

				saveFamilyTree(*root);

				showFamilyMemberTitle();

				showFamilyMember(&member, 1);

				printf("----------------\n");

				printf("成功添加以上家谱成员！\n");

			}

			else {

				printf("添加失败，家谱中未找到该名字！\n");

			}

		}

		else {

			printf("添加失败，该成员名称已经存在！\n");

		}

	}

	else {

		Member member = { 0 };

		strcpy(member.name, name);

		editFamilyMember(&member);

		*root = createTreeNode(NULL, &member);

		saveFamilyTree(*root);

		showFamilyMemberTitle();

		showFamilyMember(&member, 1);

		printf("----------------\n");

		printf("成功添加以上家谱成员！\n");

	}

	printf("╚-----------------------------------------╝\n");

}



void removeFamilyTree(pTreeNode* root) {

	pTreeNode target = NULL;

	char name[STR_LEN] = { 0 };

	printf("╔-----------------------------------------╗\n");

	printf("*  删除家谱成员 *\n");

	printf(" 输入姓名：");

	scanf("%s", name);

	target = recursiveFamilyTreeNodeFind(*root, name);

	if (target) {

		showFamilyMemberTitle();

		showFamilyMember(&target->member, 1);

		removeTreeNode(target);

		recursiveFamilyTreeNodeClear(target);

		if (target == *root) {

			*root = NULL;

		}

		saveFamilyTree(*root);

		printf("----------------\n");

		printf("成功删除以上家谱成员！\n");

	}

	else {

		printf(" 没有找到相关信息！\n");

	}

	printf("╚-----------------------------------------╝\n");

}



void findFamilyTree(pTreeNode root) {

	pTreeNode target = NULL;

	char name[STR_LEN] = { 0 };

	printf("╔-----------------------------------------╗\n");

	printf(" * 查找家谱成员 *\n");

	printf(" 输入姓名：");

	scanf("%s", name);

	target = recursiveFamilyTreeNodeFind(root, name);

	if (target) {

		int* brother_line = (int*)calloc(1024, sizeof(int));

		printf("---------------\n");

		showFamilyMemberTitle();

		showFamilyMember(&target->member, 1);

		printf("---------------\n");

		printf("【所有孩子】\n");

		recursiveFamilyTreeNodeShow(target, brother_line, 0, 0);

		free(brother_line);

		printf("【所有祖先】\n");

		showFamilyMemberTitle();

		while (target->parent) {

			target = target->parent;

			showFamilyMember(&target->member, 1);

		}

	}

	else {

		printf(" 没有找到相关信息！\n");

	}

	printf("╚-----------------------------------------╝\n");

}



void modifyFamilyTree(pTreeNode root) {

	pTreeNode target = NULL;

	char name[STR_LEN] = { 0 };

	printf("╔-----------------------------------------╗\n");

	printf(" * 修改家谱成员 *\n");

	printf(" 输入姓名：");

	scanf("%s", name);

	target = recursiveFamilyTreeNodeFind(root, name);

	if (target) {

		showFamilyMemberTitle();

		showFamilyMember(&target->member, 1);

		printf("----------------\n");

		editFamilyMember(&target->member);

		printf("----------------\n");

		saveFamilyTree(root);

		printf("成功修改以上家谱成员！\n");

	}

	else {

		printf(" 没有找到相关信息！\n");

	}

	printf("╚-----------------------------------------╝\n");

}



void statFamilyTree(pTreeNode root) {

	int count = recursiveFamilyTreeNodeCount(root);

	printf("╔-----------------------------------------╗\n");

	printf(" * 统计家谱成员 *\n");

	printf(" 成员数量：%d\n", count);

	printf("╚-----------------------------------------╝\n");

}



void menuOptions(pTreeNode root) {

	system("title 家族谱管理系统");

	while (1) {
		system("cls");
		int option = 0;

		printf("╔-----------------------------------------╗\n");

		printf(" * 家族谱管理系统 *\n");

		printf(" 1 . 显示家谱\n");

		printf(" 2 . 添加家谱成员\n");

		printf(" 3 . 删除家谱成员\n");

		printf(" 4 . 查找家谱成员\n");

		printf(" 5 . 修改家谱成员\n");

		printf(" 6 . 统计家谱成员\n");

		printf(" 0 . 退出\n");

		printf("╚-----------------------------------------╝\n");

		printf(" 请选择：");

		scanf("%d", &option);

		if (option == 0) break;

		switch (option) {
			
		case 1:

			showFamilyTree(root, 0);
			system("pause");
			break;

		case 2:

			showFamilyTree(root, 1);
			system("pause");
			break;

		case 3:

			addFamilyTree(&root);
			system("pause");

			break;

		case 4:

			removeFamilyTree(&root);
			system("pause");

			break;

		case 5:

			findFamilyTree(root);
			system("pause");

			break;

		case 6:

			modifyFamilyTree(root);
			system("pause");

			break;

		case 7:

			statFamilyTree(root);
			system("pause");

			break;

		}

	}

}



int main() {

	pTreeNode root = loadFamilyTree();
	
	menuOptions(root);

	recursiveFamilyTreeNodeClear(root);

	return 0;

}
